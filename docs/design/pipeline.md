# Pipelined Architecture Generated by Assassyn

Assassyn aims at making CI cases not only tests
functionality but are also self examplified for explanation
the idea of the project.

This document focus on the micro-architectural (aka u-arch)
paradigm of the hardware generated by Assassyn.
Three key test cases discussed below cover most
of Assassyn's core functionality.

# Driver Module

[test_driver.py](../../python/ci-tests/test_driver.py) is an example of the `Driver`,
a special module of a pipeline stage. This module is like the "main" function
entrance in software and the "clock" of a verilog system.
The driver is unconditionally activated each cycle to execute
the logic inside and drive the next stages.

```
+--------+
| Driver |
+--------+
```

# Inter-stage Sequential Communication

[test_async_call.py](../../python/ci-tests/test_async_call.py) is an example of inter-stage
sequential communication. `Driver` activates `adder` stage using async call.

## Pipeline Stage u-Arch

The figure below illustrates the 2-stage architecture in [test_async_call.py](../../python/ci-tests/test_async_call.py).

**Event Counter:** Once `driver` calls `adder` it increases the counter of adder to indicate that `adder` has a pending function call to process.
Once `adder` successfully executed once, it decreases its counter.
By successfully, we mean the condition of `wait_until` is `true`. Refer to the `wait_until` intrinsic declared in
[intrinsic.py](../../python/assassyn/ir/expr/intrinsic.py) and explained in [intrinsic.md](../../python/assassyn/ir/expr/intrinsic.md).
This is especially useful, for designs like CPU decoder stage --- when the data is not valid yet, the decode call is not cleared
to decode again next cycle.
Each cycle, `adder` checks the counter to determine if this module should be activated.
This counter micro-architecture is implemented in [a template sv](../../python/assassyn/codegen/verilog/trigger_counter.sv).

**Stage FIFO:** `Driver` feeds data to `adder` by writing data to the stage register. To keep our u-arch general,
we use a [FIFO template](../../python/assassyn/codegen/verilog/fifo.sv) as an over-engineering
as stage register.

**Async Call:** The key insight is that a module activates a downstream module like an async function call.
By async, we mean the callee does not take effect immediately, because the register writing will not
be available until the next cycle, which fits perfectly with the concept of async call.

```
              +-------+
     |------->|counter|-------+
+--------+    +-------+       |
| Driver |--[A]->|    Adder   |
|        |--[B]->|            |
+--------+       +------------+

[A] [B] are stage registers.
```

# Inter-stage Combinational Communication

[test_downstream.py](../../python/ci-tests/test_downstream.py)
examplified how cross-module same-cycle communications are done.

```
                   +---+
     +------------>|   |
     |             |cnt|-----+
+--------+         +---+     |       +------+
| Driver |--[data]->|  lhs   |------>|      |
|        |          +--------+       |      |
|        |          +--------+       | add  |
|        |--[data]->|  rhs   |------>|      |
+--------+         +---+     |       +------+
     |             |cnt|-----+
     +------------>|   |
                   +---+

[data] and [data] are stage registers.
```

`Driver` diverges by pushing data to `lhs`, and `rhs` through the
stage buffer, and then they both converge to add combinationally.
Data from `lhs` and `rhs` will arrive `add` in the same cycle.
Thus, [test_downstream.py](../../python/ci-tests/test_downstream.py)
is almost equivalent to [test_async_call.py](../../python/ci-tests/test_async_call.py).

# RegArray

Register array tested in
[test_array_multi_write.py](../../python/ci-tests/test_array_multi_write.py)
examplifies the register array generation.

````
Port1     +--------+
--we----->|        |---reader1-->
--wdata-->|  Array |
--widx--->|        |
          +--------+
           ^ ^    ^
           | |    | Port2
          we widx data
````

**Writes:** Multiple writes to an array will first be gathered by ports,
and then writes use the same port will first be one-hot selected
for enable signal `we`, data `wdata`, and index `widx`.
The register is written on `posedge` when `we` enabled.

**Read:** Currently the whole register array is routed out the module for reading.